// Copyright (c) 2021 Graphcore Ltd. All rights reserved.
#ifndef POPRITHMS_COMMON_SCHEDULABLE_SUBGRAPHID_HPP
#define POPRITHMS_COMMON_SCHEDULABLE_SUBGRAPHID_HPP

#include <algorithm>
#include <limits>
#include <vector>

#include <poprithms/common/multiout/tensorid.hpp>
#include <poprithms/error/error.hpp>
#include <poprithms/util/typedinteger.hpp>
#include <poprithms/util/typedvector.hpp>

namespace poprithms {
namespace common {
namespace schedulable {

using poprithms::common::multiout::TensorId;
using poprithms::common::multiout::TensorIds;

class SubGraphId;
using SubGraphIds = std::vector<SubGraphId>;

/// The Graph class controls the construction and generation of SubGraphIds.
class Graph;

/**
 * A class to identity distinct sub-graphs in a Graph. Sub-graphs can be any
 * partitioning of the Graph's Ops.
 * */
class SubGraphId {
public:
  SubGraphId() = delete;

  SubGraphId(const SubGraphId &) = default;
  SubGraphId(SubGraphId &&)      = default;

  SubGraphId &operator=(const SubGraphId &) = default;
  SubGraphId &operator=(SubGraphId &&)      = default;

  /**
   * methods to return SugGraphId as different integer types.
   * */
  uint32_t get_u32() const { return val; }
  int64_t get_i64() const { return static_cast<int64_t>(val); }
  uint64_t get_u64() const { return static_cast<uint64_t>(val); }

  bool operator==(const SubGraphId &rhs) const { return val == rhs.val; }
  bool operator!=(const SubGraphId &rhs) const { return !operator==(rhs); }
  bool operator<(const SubGraphId &rhs) const { return val < rhs.val; }
  bool operator>(const SubGraphId &rhs) const { return val > rhs.val; }
  bool operator<=(const SubGraphId &rhs) const { return !operator>(rhs); }
  bool operator>=(const SubGraphId &rhs) const { return !operator<(rhs); }

  std::string str() const { return std::to_string(val); }

  /**
   * The only SubGraphId which can be generated by a user other than the Graph
   * class, is the 'unset' SubGraphId.
   * */
  static SubGraphId unset() {
    return SubGraphId(std::numeric_limits<uint32_t>::max());
  }
  bool isUnset() const { return *this == unset(); }

  /**
   * Generation of new SubGraphIds is preferably controlled by the (friend)
   * schedule::Graph class. However, it is possible to create a SubGraphId
   * with this factory method, for external project interaction.
   * */
  static SubGraphId createSubGraphId(uint32_t v) { return SubGraphId(v); }

  template <typename G>
  static SubGraphIds subGraphIds(const G &g, const TensorIds &tIds) {
    SubGraphIds sgIds;
    sgIds.reserve(tIds.size());
    for (const TensorId &tId : tIds) {
      sgIds.push_back(g.subGraphId(tId));
    }
    return sgIds;
  }

  template <typename G>
  static SubGraphId fromTensorIds(const G &g, const TensorIds &ids) {

    if (ids.empty()) {
      throw poprithms::error::error(
          "common::schedulable",
          "Failed to obtain SubGraphId from empty vector of TensorIds. ");
    }

    const auto subGraphId_ = g.subGraphId(ids[0]);
    if (std::any_of(ids.cbegin() + 1,
                    ids.cend(),
                    [&subGraphId_, &g](const TensorId &id) {
                      return g.subGraphId(id) != subGraphId_;
                    })) {
      std::ostringstream oss;
      oss << "Contradictory solution while attemting to obtain "
          << "SubGraphId from the TensorIds, " << ids
          << ". Expected all TensorIds to have same SubGraphId, "
          << "but the SubGraphIds are not all identical, "
          << subGraphIds<G>(g, ids);
      throw poprithms::error::error("common::schedulable", oss.str());
    }

    return subGraphId_;
  }

  template <typename G>
  static SubGraphId fromTensorIds(const G &g,
                                  const std::vector<TensorIds> &idss) {
    return fromTensorIds<G>(g, TensorId::flatten(idss));
  }

private:
  SubGraphId(uint32_t v) : val(v) {}
  friend class Graph;
  uint32_t val;
};

std::ostream &operator<<(std::ostream &, const SubGraphIds &);
std::ostream &operator<<(std::ostream &, const SubGraphId &);

} // namespace schedulable
} // namespace common
} // namespace poprithms

namespace std {
template <> struct hash<poprithms::common::schedulable::SubGraphId> {
  std::size_t operator()(
      const poprithms::common::schedulable::SubGraphId &s) const noexcept {
    return std::hash<uint32_t>{}(s.get_u32());
  }
};
} // namespace std

#endif
